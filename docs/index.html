<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donatello Challenge Demo</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center min-h-screen p-4">

    <h1 class="text-4xl font-bold mb-8">Donatello Challenge Demo</h1>

    <div class="text-center mb-8">
        <p class="text-lg">This page demonstrates a client-side canvas rendering and hashing challenge.</p>
        <a href="https://github.com/Litebrowsers/donatello" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">GitHub Repository</a>
    </div>

    <div id="challenges" class="flex flex-wrap justify-center gap-8">

        <div id="challenge1" class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
            <h2 class="text-2xl font-semibold mb-4">Challenge 1</h2>
            <canvas id="canvas1" width="20" height="20" class="border border-gray-300 bg-gray-50 mb-4"></canvas>
            <div id="first_hash" class="text-sm font-mono" style="display: none;"></div>
        </div>

        <div id="challenge2" class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
            <h2 class="text-2xl font-semibold mb-4">Challenge 2</h2>
            <canvas id="canvas2" width="20" height="20" class="border border-gray-300 bg-gray-50 mb-4"></canvas>
            <div id="second_hash" class="text-sm font-mono" style="display: none;"></div>
        </div>

    </div>

    <button onclick="runChallenge()" class="mt-8 px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
        New Challenge
    </button>

    <p class="mt-4 text-sm text-gray-500">Time taken: <span id="time-taken">N/A</span></p>
    <p class="mt-4 text-sm text-gray-500">Noise detected: <span id="noise-detected">N/A</span></p>
    <p class="mt-4 text-sm text-gray-500">Fingerprint: <span id="fingerprint">N/A</span></p>
    <p class="mt-4 text-sm text-gray-500">Noise Fingerprint: <span id="noise-fingerprint">N/A</span></p>

    <script>
        // --- Backend Logic (translated from Go) ---

        const CANVAS_SIZE = 20;

        function generateRandomColor() {
            return Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0').toUpperCase();
        }

        function generateRandomEvenSizedPrimitives(canvasSize, count) {
            const primitives = [];
            for (let i = 0; i < count; i++) {
                let newShape;
                if (Math.random() < 0.5) { // Even-sided Square
                    const side = (Math.floor(Math.random() * 5) + 1) * 2;
                    newShape = `R:${generateRandomColor()}:${side}:${side}:${Math.floor(Math.random() * (canvasSize - side))}:${Math.floor(Math.random() * (canvasSize - side))}`;
                } else { // Line
                    const thickness = (Math.floor(Math.random() * 2) + 1) * 2;
                    if (Math.random() < 0.5) {
                        const x = Math.floor(Math.random() * (canvasSize - thickness));
                        const y1 = Math.floor(Math.random() * canvasSize);
                        const y2 = Math.floor(Math.random() * canvasSize);
                        newShape = `L:${generateRandomColor()}:${x}:${y1}:${x}:${y2}:${thickness}`;
                    } else {
                        const y = Math.floor(Math.random() * (canvasSize - thickness));
                        const x1 = Math.floor(Math.random() * canvasSize);
                        const x2 = Math.floor(Math.random() * canvasSize);
                        newShape = `L:${generateRandomColor()}:${x1}:${y}:${x2}:${y}:${thickness}`;
                    }
                }
                primitives.push(newShape);
            }
            return primitives.join(';');
        }

        function generateRandomShapes(canvasSize, count) {
            const shapes = [];
            for (let i = 0; i < count; i++) {
                let newShape;
                const shapeType = Math.floor(Math.random() * 5);
                switch (shapeType) {
                    case 0: // Rectangle
                        const w = Math.floor(Math.random() * (canvasSize / 2)) + 1;
                        const h = Math.floor(Math.random() * (canvasSize / 2)) + 1;
                        newShape = `R:${generateRandomColor()}:${w}:${h}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}`;
                        break;
                    case 1: // Circle
                        const r = Math.floor(Math.random() * (canvasSize / 4)) + 1;
                        newShape = `C:${generateRandomColor()}:${r}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}`;
                        break;
                    case 2: // Triangle
                        newShape = `T:${generateRandomColor()}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}`;
                        break;
                    case 3: // Line
                        newShape = `L:${generateRandomColor()}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * 2) + 1}`;
                        break;
                    case 4: // Ellipse
                        const rx = Math.floor(Math.random() * (canvasSize / 2)) + 1;
                        const ry = Math.floor(Math.random() * (canvasSize / 2)) + 1;
                        newShape = `E:${generateRandomColor()}:${rx}:${ry}:${Math.floor(Math.random() * canvasSize)}:${Math.floor(Math.random() * canvasSize)}`;
                        break;
                }
                shapes.push(newShape);
            }
            return shapes.join(';');
        }

        class ServerCanvas {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.r = new Uint8Array(width * height).fill(0);
                this.g = new Uint8Array(width * height).fill(0);
                this.b = new Uint8Array(width * height).fill(0);
                this.a = new Uint8Array(width * height).fill(0);
            }

            hexToRGBA(hex) {
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return { r, g, b, a: 255 };
            }

            drawRectangle(r) {
                const col = this.hexToRGBA(r.color);
                for (let y = r.y; y < r.y + r.h; y++) {
                    for (let x = r.x; x < r.x + r.w; x++) {
                        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                            const i = y * this.width + x;
                            this.r[i] = col.r;
                            this.g[i] = col.g;
                            this.b[i] = col.b;
                            this.a[i] = col.a;
                        }
                    }
                }
            }
            
            drawLine(l) {
                const col = this.hexToRGBA(l.color);
                const half = Math.floor(l.thickness / 2);

                if (l.x1 === l.x2) { // Vertical
                    const y1 = Math.min(l.y1, l.y2);
                    const y2 = Math.max(l.y1, l.y2);
                    for (let y = y1; y < y2; y++) {
                        for (let x = l.x1 - half; x < l.x1 + half; x++) {
                             if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                                const i = y * this.width + x;
                                this.r[i] = col.r;
                                this.g[i] = col.g;
                                this.b[i] = col.b;
                                this.a[i] = col.a;
                            }
                        }
                    }
                } else if (l.y1 === l.y2) { // Horizontal
                    const x1 = Math.min(l.x1, l.x2);
                    const x2 = Math.max(l.x1, l.x2);
                     for (let y = l.y1 - half; y < l.y1 + half; y++) {
                        for (let x = x1; x < x2; x++) {
                             if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                                const i = y * this.width + x;
                                this.r[i] = col.r;
                                this.g[i] = col.g;
                                this.b[i] = col.b;
                                this.a[i] = col.a;
                            }
                        }
                    }
                }
            }

            drawShapes(taskString) {
                const shapes = taskString.split(';');
                shapes.forEach(shapeStr => {
                    if (!shapeStr) return;
                    const parts = shapeStr.split(':');
                    const type = parts[0];
                    const color = parts[1];
                    switch (type) {
                        case 'R':
                            this.drawRectangle({ color, w: parseInt(parts[2]), h: parseInt(parts[3]), x: parseInt(parts[4]), y: parseInt(parts[5]) });
                            break;
                        case 'L':
                             this.drawLine({ color, x1: parseInt(parts[2]), y1: parseInt(parts[3]), x2: parseInt(parts[4]), y2: parseInt(parts[5]), thickness: parseInt(parts[6]) });
                            break;
                    }
                });
            }

            async calculateHashes() {
                const [rHash, gHash, bHash, aHash] = await Promise.all([
                    sha256(this.r),
                    sha256(this.g),
                    sha256(this.b),
                    sha256(this.a)
                ]);
                return { r: rHash, g: gHash, b: bHash, a: aHash };
            }

            async calculateCombinedHash() {
                const hashes = await this.calculateHashes();
                const combined = hashes.r + hashes.g + hashes.b + hashes.a;
                const combinedHash = await sha256(new TextEncoder().encode(combined));
                return { combinedHash, hashes, channels: { r: this.r, g: this.g, b: this.b, a: this.a } };
            }
        }


        // --- Frontend Logic (from index.html) ---

        function drawRectangle(ctx, color, w, h, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.fillRect(x, y, w, h);
        }

        function drawCircle(ctx, color, r, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTriangle(ctx, color, x1, y1, x2, y2, x3, y3) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();
            ctx.fill();
        }

        function drawLine(ctx, color, x1, y1, x2, y2, thickness) {
            ctx.strokeStyle = '#' + color;
            ctx.lineWidth = thickness;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawEllipse(ctx, color, rx, ry, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        async function sha256(uint8Array) {
            const buf = await crypto.subtle.digest("SHA-256", uint8Array);
            return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function drawTask(ctx, taskString) {
            if (!taskString) {
                console.error('No task string received');
                return;
            }
            const shapes = taskString.split(';');
            shapes.forEach(shapeStr => {
                if (!shapeStr) return;
                const parts = shapeStr.split(':');
                const type = parts[0];
                const color = parts[1];

                switch (type) {
                    case 'R':
                        drawRectangle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]));
                        break;
                    case 'C':
                        drawCircle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]));
                        break;
                    case 'T':
                        drawTriangle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]), parseInt(parts[6]), parseInt(parts[7]));
                        break;
                    case 'L':
                        drawLine(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]), parseInt(parts[6]));
                        break;
                    case 'E':
                        drawEllipse(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]));
                        break;
                    default:
                        console.warn('Unknown shape type:', type);
                }
            });
        }

        async function getClientCombinedHash(canvas, mode = "combined") {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const rChannel = new Uint8Array(canvas.width * canvas.height);
            const gChannel = new Uint8Array(canvas.width * canvas.height);
            const bChannel = new Uint8Array(canvas.width * canvas.height);
            const aChannel = new Uint8Array(canvas.width * canvas.height);

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    const pixelIndex = y * canvas.width + x;
                    rChannel[pixelIndex] = data[i];
                    gChannel[pixelIndex] = data[i + 1];
                    bChannel[pixelIndex] = data[i + 2];
                    aChannel[pixelIndex] = data[i + 3];
                }
            }

            const channels = {
                r: rChannel,
                g: gChannel,
                b: bChannel,
                a: aChannel,
            };

            const [rHash, gHash, bHash, aHash] = await Promise.all([
                sha256(rChannel),
                sha256(gChannel),
                sha256(bChannel),
                sha256(aChannel)
            ]);

            const hashes = {
                r: rHash,
                g: gHash,
                b: bHash,
                a: aHash,
            };

            if (mode === "separate") {
                return { hashes, channels };
            }

            const combinedHash = await sha256(
                new TextEncoder().encode(rHash + gHash + bHash + aHash)
            );
            return { combinedHash, hashes, channels };
        }

        const STATIC_SECOND_TASK = 'R:FF0000:10:10:5:5;C:00FF00:5:15:15';

        async function calculateNoiseFingerprint(expected, client) {
            const diffR = new Uint8Array(expected.r.length);
            const diffG = new Uint8Array(expected.g.length);
            const diffB = new Uint8Array(expected.b.length);
            const diffA = new Uint8Array(expected.a.length);

            for (let i = 0; i < expected.r.length; i++) {
                diffR[i] = Math.abs(expected.r[i] - client.r[i]);
                diffG[i] = Math.abs(expected.g[i] - client.g[i]);
                diffB[i] = Math.abs(expected.b[i] - client.b[i]);
                diffA[i] = Math.abs(expected.a[i] - client.a[i]);
            }

            const combinedDiff = new Uint8Array(diffR.length + diffG.length + diffB.length + diffA.length);
            combinedDiff.set(diffR, 0);
            combinedDiff.set(diffG, diffR.length);
            combinedDiff.set(diffB, diffR.length + diffG.length);
            combinedDiff.set(diffA, diffR.length + diffG.length + diffB.length);

            return await sha256(combinedDiff);
        }

        async function runChallenge() {
            const startTime = performance.now();

            // --- Challenge Generation ---
            const firstTask = generateRandomEvenSizedPrimitives(CANVAS_SIZE, Math.floor(Math.random() * 6) + 1);
            const secondTask = STATIC_SECOND_TASK;

            // --- Server-side Hash Calculation ---
            const serverCanvas1 = new ServerCanvas(CANVAS_SIZE, CANVAS_SIZE);
            serverCanvas1.drawShapes(firstTask);
            const { combinedHash: expectedHash1, hashes: expectedHashes1, channels: expectedChannels1 } = await serverCanvas1.calculateCombinedHash();

            const serverCanvas2 = new ServerCanvas(CANVAS_SIZE, CANVAS_SIZE);
            serverCanvas2.drawShapes(secondTask);
            const expectedHashes2 = await serverCanvas2.calculateHashes();
            const expectedCombinedHash2 = await sha256(new TextEncoder().encode(expectedHashes2.r + expectedHashes2.g + expectedHashes2.b + expectedHashes2.a));


            // --- Client-side Drawing ---
            const canvas1 = document.getElementById('canvas1');
            const ctx1 = canvas1.getContext('2d', { willReadFrequently: true });
            const canvas2 = document.getElementById('canvas2');
            const ctx2 = canvas2.getContext('2d', { willReadFrequently: true });

            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

            drawTask(ctx1, firstTask);
            drawTask(ctx2, secondTask);

            // --- Client-side Hash Calculation ---
            const { combinedHash: clientHash1, hashes: clientHashes1, channels: clientChannels1 } = await getClientCombinedHash(canvas1);


            const { hashes: clientHashes2, channels: clientChannels2 } = await getClientCombinedHash(canvas2, "separate");
            const clientCombinedHash2 = await sha256(new TextEncoder().encode(clientHashes2.r + clientHashes2.g + clientHashes2.b + clientHashes2.a));
            document.getElementById('second_hash').textContent = clientHashes2.a;
            document.getElementById('fingerprint').textContent = clientHashes2.a;


            // --- Verification ---
            const noiseDetected = expectedHash1 !== clientHash1;

            document.getElementById('noise-detected').textContent = noiseDetected;

            if (noiseDetected) {
                const noiseFingerprint = await calculateNoiseFingerprint(expectedChannels1, clientChannels1);
                document.getElementById('noise-fingerprint').textContent = noiseFingerprint;
            } else {
                document.getElementById('noise-fingerprint').textContent = 'n/a';
            }

            const endTime = performance.now();
            const timeTaken = endTime - startTime;
            document.getElementById('time-taken').textContent = `${timeTaken.toFixed(2)} ms`;
        }

        // Run a challenge when the page loads
        runChallenge();
    </script>

    <div class="text-center mt-8">
        <p class="text-lg">Challenge 1 is for noise detection.</p>
        <p class="text-lg">Challenge 2 is static for the analysis of Chromium-based browsers and is for calculating the real fingerprint.</p>
    </div>
</body>
</html>
