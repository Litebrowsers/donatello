<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donatello Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center min-h-screen p-4">

    <h1 class="text-4xl font-bold mb-8">Donatello Challenge</h1>

    <div id="challenges" class="flex flex-wrap justify-center gap-8">

        <div id="challenge1" class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
            <h2 class="text-2xl font-semibold mb-4">Challenge 1</h2>
            <canvas id="canvas1" width="20" height="20" class="border border-gray-300 bg-gray-50 mb-4" style="display: none;"></canvas>
            <div id="first_hash" class="text-sm font-mono"></div>
        </div>

        <div id="challenge2" class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
            <h2 class="text-2xl font-semibold mb-4">Challenge 2</h2>
            <canvas id="canvas2" width="20" height="20" class="border border-gray-300 bg-gray-50 mb-4" style="display: none;"></canvas>
            <div id="second_hash" class="text-sm font-mono"></div>
        </div>

    </div>

    <button onclick="fetchAndDrawChallenge()" class="mt-8 px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
        New Challenge
    </button>

    <p class="mt-4 text-sm text-gray-500">Time taken: <span id="time-taken">N/A</span></p>
    <p class="mt-4 text-sm text-gray-500">Noise detected: <span id="noise-detected">N/A</span></p>

    <script>


        async function calculateNoiseFingerprint(expected, client) {
            const diffR = new Uint8Array(expected.r.length);
            const diffG = new Uint8Array(expected.g.length);
            const diffB = new Uint8Array(expected.b.length);
            const diffA = new Uint8Array(expected.a.length);

            for (let i = 0; i < expected.r.length; i++) {
                diffR[i] = Math.abs(expected.r[i] - client.r[i]);
                diffG[i] = Math.abs(expected.g[i] - client.g[i]);
                diffB[i] = Math.abs(expected.b[i] - client.b[i]);
                diffA[i] = Math.abs(expected.a[i] - client.a[i]);
            }

            const combinedDiff = new Uint8Array(diffR.length + diffG.length + diffB.length + diffA.length);
            combinedDiff.set(diffR, 0);
            combinedDiff.set(diffG, diffR.length);
            combinedDiff.set(diffB, diffR.length + diffG.length);
            combinedDiff.set(diffA, diffR.length + diffG.length + diffB.length);

            return await sha256(combinedDiff);
        }

        function drawRectangle(ctx, color, w, h, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.fillRect(x, y, w, h);
        }

        function drawCircle(ctx, color, r, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTriangle(ctx, color, x1, y1, x2, y2, x3, y3) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();
            ctx.fill();
        }

        function drawLine(ctx, color, x1, y1, x2, y2, thickness) {
            ctx.strokeStyle = '#' + color;
            ctx.lineWidth = thickness;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawEllipse(ctx, color, rx, ry, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        async function sha256(uint8Array) {
            const buf = await crypto.subtle.digest("SHA-256", uint8Array);
            return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function drawTask(ctx, taskString) {
            if (!taskString) {
                console.error('No task string received');
                return;
            }
            const shapes = taskString.split(';');
            shapes.forEach(shapeStr => {
                if (!shapeStr) return;
                const parts = shapeStr.split(':');
                const type = parts[0];
                const color = parts[1];

                switch (type) {
                    case 'R':
                        drawRectangle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]));
                        break;
                    case 'C':
                        drawCircle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]));
                        break;
                    case 'T':
                        drawTriangle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]), parseInt(parts[6]), parseInt(parts[7]));
                        break;
                    case 'L':
                        drawLine(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]), parseInt(parts[6]));
                        break;
                    case 'E':
                        drawEllipse(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]));
                        break;
                    default:
                        console.warn('Unknown shape type:', type);
                }
            });
        }

        async function getCombinedHash(canvas) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const rChannel = new Uint8Array(canvas.width * canvas.height);
            const gChannel = new Uint8Array(canvas.width * canvas.height);
            const bChannel = new Uint8Array(canvas.width * canvas.height);
            const aChannel = new Uint8Array(canvas.width * canvas.height);

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    const pixelIndex = y * canvas.width + x;
                    rChannel[pixelIndex] = data[i];
                    gChannel[pixelIndex] = data[i + 1];
                    bChannel[pixelIndex] = data[i + 2];
                    aChannel[pixelIndex] = data[i + 3];
                }
            }

            const channels = {
                r: rChannel,
                g: gChannel,
                b: bChannel,
                a: aChannel,
            };

            const [rHash, gHash, bHash, aHash] = await Promise.all([
                sha256(rChannel),
                sha256(gChannel),
                sha256(bChannel),
                sha256(aChannel)
            ]);

            const hashes = {
                r: rHash,
                g: gHash,
                b: bHash,
                a: aHash,
            };

            return { hashes, channels };
        }

        async function fetchAndDrawChallenge() {
            const startTime = performance.now();

            const canvas1 = document.getElementById('canvas1');
            const ctx1 = canvas1.getContext('2d', { willReadFrequently: true });
            const canvas2 = document.getElementById('canvas2');
            const ctx2 = canvas2.getContext('2d', { willReadFrequently: true });

            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

            try {
                const response = await fetch('/challenge');
                const data = await response.json();

                drawTask(ctx1, data.first_task);
                drawTask(ctx2, data.second_task);

                const worker = new Worker('predictor.worker.js');
                worker.postMessage({
                    taskString: data.first_task,
                    width: canvas1.width,
                    height: canvas1.height
                });

                const handleWorkerMessage = async (e) => {
                    const { combinedHash: expectedHash1, channels: expectedChannels1 } = e.data;

                    const { hashes: hashesCanvas1, channels: channelsCanvas1 } = await getCombinedHash(canvas1);
                    document.getElementById('first_hash').textContent = hashesCanvas1.a;

                    const { hashes: hashesCanvas2, channels: channelsCanvas2 } = await getCombinedHash(canvas2);
                    document.getElementById('second_hash').textContent = hashesCanvas2.a;

                    const totalHash1 = await sha256(
                        new TextEncoder().encode(hashesCanvas1["r"] + hashesCanvas1["g"] + hashesCanvas1["b"] + hashesCanvas1["a"])
                    );

                    const result = {
                        id: data.id,
                        totalHash1: totalHash1,
                        totalHash2: hashesCanvas2['a'],
                    };

                    if (totalHash1 !== expectedHash1) {
                        result.diffHash = await calculateNoiseFingerprint(expectedChannels1, channelsCanvas1);
                    }

                    const answer_response = await fetch('/challenge', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(result),
                    });

                    const answer_data = await answer_response.json();
                    if (answer_response.status === 200) {
                        document.getElementById('noise-detected').textContent = answer_data.noise_detected;
                    }

                    worker.terminate();
                    const endTime = performance.now();
                    const timeTaken = endTime - startTime;
                    document.getElementById('time-taken').textContent = `${timeTaken.toFixed(2)} ms`;
                };

                const handleWorkerError = (e) => {
                    console.error('Error from worker:', e);
                    worker.terminate();
                    const endTime = performance.now();
                    const timeTaken = endTime - startTime;
                    document.getElementById('time-taken').textContent = `Error after ${timeTaken.toFixed(2)} ms`;
                };

                worker.onmessage = handleWorkerMessage;
                worker.onerror = handleWorkerError;

            } catch (error) {
                console.error('Error fetching or drawing challenge:', error);
                const endTime = performance.now();
                const timeTaken = endTime - startTime;
                document.getElementById('time-taken').textContent = `Error after ${timeTaken.toFixed(2)} ms`;
            }
        }

        // Fetch and draw a challenge when the page loads
        fetchAndDrawChallenge();
    </script>
</body>
</html>