<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donatello Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center min-h-screen p-4">

    <h1 class="text-4xl font-bold mb-8">Donatello Challenge</h1>

    <div id="challenges" class="flex flex-wrap justify-center gap-8">

        <div id="challenge1" class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
            <h2 class="text-2xl font-semibold mb-4">Challenge 1</h2>
            <canvas id="canvas1" width="20" height="20" class="border border-gray-300 bg-gray-50 mb-4"></canvas>
            <div id="total-hash1" class="text-sm font-mono"></div>
        </div>

        <div id="challenge2" class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
            <h2 class="text-2xl font-semibold mb-4">Challenge 2</h2>
            <canvas id="canvas2" width="20" height="20" class="border border-gray-300 bg-gray-50 mb-4"></canvas>
            <div id="total-hash2" class="text-sm font-mono"></div>
        </div>

    </div>

    <button onclick="fetchAndDrawChallenge()" class="mt-8 px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
        New Challenge
    </button>

    <p class="mt-4 text-sm text-gray-500">Time taken: <span id="time-taken">N/A</span></p>
    <p class="mt-4 text-sm text-gray-500">Noise detected: <span id="noise-detected">N/A</span></p>

    <script>
        function drawRectangle(ctx, color, w, h, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.fillRect(x, y, w, h);
        }

        function drawCircle(ctx, color, r, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTriangle(ctx, color, x1, y1, x2, y2, x3, y3) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();
            ctx.fill();
        }

        function drawLine(ctx, color, x1, y1, x2, y2, thickness) {
            ctx.strokeStyle = '#' + color;
            ctx.lineWidth = thickness;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawEllipse(ctx, color, rx, ry, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        async function sha256(uint8Array) {
            const buf = await crypto.subtle.digest("SHA-256", uint8Array);
            return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function drawTask(ctx, taskString) {
            if (!taskString) {
                console.error('No task string received');
                return;
            }
            const shapes = taskString.split(';');
            shapes.forEach(shapeStr => {
                if (!shapeStr) return;
                const parts = shapeStr.split(':');
                const type = parts[0];
                const color = parts[1];

                switch (type) {
                    case 'R':
                        drawRectangle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]));
                        break;
                    case 'C':
                        drawCircle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]));
                        break;
                    case 'T':
                        drawTriangle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]), parseInt(parts[6]), parseInt(parts[7]));
                        break;
                    case 'L':
                        drawLine(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]), parseInt(parts[6]));
                        break;
                    case 'E':
                        drawEllipse(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]));
                        break;
                    default:
                        console.warn('Unknown shape type:', type);
                }
            });
        }

        async function calculateCombinedHash(canvas) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const rChannel = new Uint8Array(canvas.width * canvas.height);
            const gChannel = new Uint8Array(canvas.width * canvas.height);
            const bChannel = new Uint8Array(canvas.width * canvas.height);
            const aChannel = new Uint8Array(canvas.width * canvas.height);

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    const pixelIndex = y * canvas.width + x;
                    rChannel[pixelIndex] = data[i];
                    gChannel[pixelIndex] = data[i + 1];
                    bChannel[pixelIndex] = data[i + 2];
                    aChannel[pixelIndex] = data[i + 3];
                }
            }

            const clientRedHash = await sha256(rChannel);
            const clientGreenHash = await sha256(gChannel);
            const clientBlueHash = await sha256(bChannel);
            const clientAlphaHash = await sha256(aChannel);

            const combinedHash = await sha256(new TextEncoder().encode(clientRedHash + clientGreenHash + clientBlueHash + clientAlphaHash));
            return combinedHash;
        }

        async function fetchAndDrawChallenge() {
            const startTime = performance.now();

            const canvas1 = document.getElementById('canvas1');
            const ctx1 = canvas1.getContext('2d', { willReadFrequently: true });
            const canvas2 = document.getElementById('canvas2');
            const ctx2 = canvas2.getContext('2d', { willReadFrequently: true });

            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

            try {
                const response = await fetch('/challenge');
                const data = await response.json();

                drawTask(ctx1, data.first_task);
                drawTask(ctx2, data.second_task);

                const totalHash1 = await calculateCombinedHash(canvas1);
                document.getElementById('total-hash1').textContent = totalHash1;

                const totalHash2 = await calculateCombinedHash(canvas2);
                document.getElementById('total-hash2').textContent = totalHash2;

                const answer_response = await fetch('/challenge', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        id: data.id,
                        totalHash1: totalHash1,
                        totalHash2: totalHash2,
                    }),
                });

                const answer_data = await answer_response.json();
                if (answer_response.status === 200) {
                    document.getElementById('noise-detected').textContent = answer_data.noise_detected;
                }

            } catch (error) {
                console.error('Error fetching or drawing challenge:', error);
            } finally {
                const endTime = performance.now();
                const timeTaken = endTime - startTime;
                document.getElementById('time-taken').textContent = `${timeTaken.toFixed(2)} ms`;
            }
        }

        // Fetch and draw a challenge when the page loads
        fetchAndDrawChallenge();
    </script>
</body>
</html>