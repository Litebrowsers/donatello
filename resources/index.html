<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donatello Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center min-h-screen p-4">

    <h1 class="text-4xl font-bold mb-8">Donatello Challenge</h1>

    <div id="challenges" class="flex flex-wrap justify-center gap-8">

        <div id="challenge1" class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
            <h2 class="text-2xl font-semibold mb-4">Challenge 1</h2>
            <canvas id="canvas1" width="20" height="20" class="border border-gray-300 bg-gray-50 mb-4" style="display: none;"></canvas>
            <div id="first_hash" class="text-sm font-mono"></div>
        </div>

        <div id="challenge2" class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
            <h2 class="text-2xl font-semibold mb-4">Challenge 2</h2>
            <canvas id="canvas2" width="20" height="20" class="border border-gray-300 bg-gray-50 mb-4" style="display: none;"></canvas>
            <div id="second_hash" class="text-sm font-mono"></div>
        </div>

    </div>

    <button onclick="fetchAndDrawChallenge()" class="mt-8 px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
        New Challenge
    </button>

    <p class="mt-4 text-sm text-gray-500">Time taken: <span id="time-taken">N/A</span></p>
    <p class="mt-4 text-sm text-gray-500">Noise detected: <span id="noise-detected">N/A</span></p>

    <script>
        function drawRectangle(ctx, color, w, h, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.fillRect(x, y, w, h);
        }

        function drawCircle(ctx, color, r, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTriangle(ctx, color, x1, y1, x2, y2, x3, y3) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();
            ctx.fill();
        }

        function drawLine(ctx, color, x1, y1, x2, y2, thickness) {
            ctx.strokeStyle = '#' + color;
            ctx.lineWidth = thickness;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawEllipse(ctx, color, rx, ry, x, y) {
            ctx.fillStyle = '#' + color;
            ctx.beginPath();
            ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        async function sha256(uint8Array) {
            const buf = await crypto.subtle.digest("SHA-256", uint8Array);
            return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function drawTask(ctx, taskString) {
            if (!taskString) {
                console.error('No task string received');
                return;
            }
            const shapes = taskString.split(';');
            shapes.forEach(shapeStr => {
                if (!shapeStr) return;
                const parts = shapeStr.split(':');
                const type = parts[0];
                const color = parts[1];

                switch (type) {
                    case 'R':
                        drawRectangle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]));
                        break;
                    case 'C':
                        drawCircle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]));
                        break;
                    case 'T':
                        drawTriangle(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]), parseInt(parts[6]), parseInt(parts[7]));
                        break;
                    case 'L':
                        drawLine(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]), parseInt(parts[6]));
                        break;
                    case 'E':
                        drawEllipse(ctx, color, parseInt(parts[2]), parseInt(parts[3]), parseInt(parts[4]), parseInt(parts[5]));
                        break;
                    default:
                        console.warn('Unknown shape type:', type);
                }
            });
        }

        async function calculateCombinedHash(canvas, mode = "combined") {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const rChannel = new Uint8Array(canvas.width * canvas.height);
            const gChannel = new Uint8Array(canvas.width * canvas.height);
            const bChannel = new Uint8Array(canvas.width * canvas.height);
            const aChannel = new Uint8Array(canvas.width * canvas.height);

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    const pixelIndex = y * canvas.width + x;
                    rChannel[pixelIndex] = data[i];
                    gChannel[pixelIndex] = data[i + 1];
                    bChannel[pixelIndex] = data[i + 2];
                    aChannel[pixelIndex] = data[i + 3];
                }
            }

            const [rHash, gHash, bHash, aHash] = await Promise.all([
                sha256(rChannel),
                sha256(gChannel),
                sha256(bChannel),
                sha256(aChannel)
            ]);

            if (mode === "separate") {
                return {
                    r: rHash,
                    g: gHash,
                    b: bHash,
                    a: aHash,
                    a_pixels: aChannel
                };
            }

            const combinedHash = await sha256(
                new TextEncoder().encode(rHash + gHash + bHash + aHash)
            );
            return combinedHash;
        }

        function findContourValuesWithPositions(arr, coreValue = 255) {
            const n = Math.sqrt(arr.length);
            if (!Number.isInteger(n)) throw new Error("Длина массива должна быть квадратом");

            const matrix = [];
            for (let i = 0; i < n; i++) matrix.push(arr.slice(i * n, (i + 1) * n));

            const offsets = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];

            const contourValues = [];

            for (let y = 0; y < n; y++) {
                for (let x = 0; x < n; x++) {
                    if (matrix[y][x] === coreValue) {
                        for (const [dy, dx] of offsets) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < n && nx >= 0 && nx < n) {
                                const v = matrix[ny][nx];
                                if (v > 0 && v < coreValue) {
                                    contourValues.push({value: v, dy, dx, y: ny, x: nx});
                                }
                            }
                        }
                    }
                }
            }

            console.log(contourValues);

            return contourValues;
        }

        async function fetchAndDrawChallenge() {
            const startTime = performance.now();

            const canvas1 = document.getElementById('canvas1');
            const ctx1 = canvas1.getContext('2d', { willReadFrequently: true });
            const canvas2 = document.getElementById('canvas2');
            const ctx2 = canvas2.getContext('2d', { willReadFrequently: true });

            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

            try {
                const response = await fetch('/challenge');
                const data = await response.json();

                drawTask(ctx1, data.first_task);
                drawTask(ctx2, data.second_task);

                console.log(data.second_task);
                const totalHash1 = await calculateCombinedHash(canvas1);
                document.getElementById('first_hash').textContent = totalHash1;

                const hashes = await calculateCombinedHash(canvas2, "separate");
                document.getElementById('second_hash').textContent = hashes['a'];

                const a_pixel =  hashes['a_pixels']

                findContourValuesWithPositions(a_pixel);

                const answer_response = await fetch('/challenge', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        id: data.id,
                        totalHash1: totalHash1,
                        totalHash2: hashes['a'],
                    }),
                });

                const answer_data = await answer_response.json();
                if (answer_response.status === 200) {
                    document.getElementById('noise-detected').textContent = answer_data.noise_detected;
                }

            } catch (error) {
                console.error('Error fetching or drawing challenge:', error);
            } finally {
                const endTime = performance.now();
                const timeTaken = endTime - startTime;
                document.getElementById('time-taken').textContent = `${timeTaken.toFixed(2)} ms`;
            }
        }

        // Fetch and draw a challenge when the page loads
        fetchAndDrawChallenge();
    </script>
</body>
</html>